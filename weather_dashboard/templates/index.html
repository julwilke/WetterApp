<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Dashboard - WetterApp</title>
    <!-- Bootstrap CSS removed: custom CSS consolidated into /static/styles.css -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito:200,300,400,600,700,800,900">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="/static/styles.css">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body id="page-top">
    <div id="wrapper">
        <!--
            Sidebar: left navigation containing the brand and links
            This is the main entry point for the UI and contains app branding
            and navigation links to switch pages (Dashboard, History, ...)
            We intentionally keep styling minimal and responsive.
        -->
        <nav id="sidebar" class="navbar navbar-dark align-items-start sidebar sidebar-dark accordion bg p-0">
            <div class="container-fluid d-flex flex-column p-0"><a class="navbar-brand d-flex justify-content-center align-items-center sidebar-brand m-0" href="#" style="text-decoration: none;">
                    <div class="sidebar-brand-icon rotate-n-15"><i class="fas fa-cloud-sun"></i></div>
                    <div class="sidebar-brand-text mx-3"><span>Wetter-App</span></div>
                </a>
                <!-- main menu: list of nav items (each has a .nav-link) -->
                <ul class="navbar-nav text-light" id="accordionSidebar">
                    <li class="nav-item"><a class="nav-link active" href="/"><i class="fas fa-tachometer-alt"></i><span>Dashboard</span></a></li>
                    <li class="nav-item"><a class="nav-link" href="/history"><i class="fas fa-table"></i><span>Verlauf</span></a></li>
                </ul>
                <div class="text-center d-none d-md-inline"><button class="btn rounded-circle border-0" id="sidebarToggle" type="button"></button></div>
            </div>
        </nav>
        <div class="d-flex flex-column" id="content-wrapper">
            <div id="content">
                <nav id="navbar" class="navbar navbar-light navbar-expand shadow mb-4 topbar static-top">
                    <div class="container-fluid">
                        <button class="btn btn-link d-md-none rounded-circle me-3" id="sidebarToggleTop" type="button"><i class="fas fa-bars"></i></button>
                        <form class="d-none d-sm-inline-block me-auto ms-md-3 my-2 my-md-0 mw-100 navbar-search navbar-form" >
                            <div class="input-group"><input id="cityInput" class="bg-light form-control border-0 small" type="text" placeholder="Suche nach Stadt..."><button id="cityButton" class="btn btn-primary" type="button"><i class="fas fa-search"></i></button></div>
                        </form>
                        <ul class="navbar-nav flex-nowrap ms-auto">
                            <li class="nav-item dropdown no-arrow mx-1">
                                <div class="nav-item dropdown no-arrow"><a class="dropdown-toggle nav-link nav-icon no-arrow" aria-expanded="false" data-bs-toggle="dropdown" href="#"><i class="fab fa-cloudscale fa-fw"></i></a>
                                            <div class="dropdown-menu dropdown-menu-end bg-dark border-dark dropdown-list animated--grow-in">
                                                <h6 class="dropdown-header border-dark menu-header" style="margin-top: 0px; color: white">API Status</h6>
                                                <div class="menu-padding">
                                                    <!-- apiRows is populated dynamically by updateApiStatus() -->
                                                    <div id="apiRows" class="api-rows d-flex flex-column" style="gap:10px;">
                                                        <!-- Populated via JavaScript using /status -> body.apis map -->
                                                    </div>
                                                </div>
                                            </div>
                                </div>
                            </li>
                            <li class="nav-item dropdown no-arrow"><a class="nav-link nav-icon" href="https://github.com/julwilke/WetterApp" target="_blank"><i class="fab fa-github"></i></a></li>
                        </ul>
                    </div>
                </nav>

                <div class="container-fluid">
                    <!-- Page heading + small action button on the right -->
                    <div class="d-sm-flex justify-content-between align-items-center mb-4">
                        <h3 class="mb-0" id="cityDisplay">--</h3><a class="btn btn-primary btn-sm d-none d-sm-inline-block" role="button" href="#"><i class="fas fa-download fa-sm text-white-50"></i>&nbsp;Generate Report</a>
                    </div>

                    <div id="dashboard" class="row">
                        <!-- Cards are injected into this container via client-side JS.
                             The script dynamically creates a tile per var listed in
                             the `weatherVars` array (see script below).
                             Do not hard-code cards in HTML; the script expects to
                             find and update elements by ID matching the var names. -->
                    </div>

                    <!-- additional layout sections could follow (charts etc.) -->
                </div>
            </div>
            <footer class="bg-white sticky-footer">
                <div class="container my-auto">
                    <div class="text-center my-auto copyright">Copyright ¬© WetterApp 2025</div>
                </div>
            </footer>
        </div><a class="border rounded d-inline scroll-to-top" href="#page-top"><i class="fas fa-angle-up"></i></a>
    </div>

    <!-- History Modal -->
    <div id="historyOverlay" class="history-hidden">
        <div id="historyModal">
            <div id="historyHeader">
                <strong id="historyTitle">Verlauf</strong>
                <button id="historyClose">‚úï</button>
            </div>
        </div>
    </div>

    <!-- keep project scripts and the inline dashboard script intact -->
    <script src="/static/js/chart.min.js"></script>
    <script src="/static/js/bs-init.js"></script>
    <script src="/static/js/theme.js"></script>
    <!-- Plotly library and helpers for sun-parabola visualization -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="/static/script.js"></script>

    <script>

        // Original dashboard script preserved to keep all functions
        const socket = io();

        const form = document.querySelector('.navbar-form');
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            cityButton.click();
        });

        // Display order for cards
        // ------------------------------------------------------------------
        // This array defines the order and content of dashboard tiles generated
        // during page initialization. Each key has a label and a mapping to a
        // visual icon (see `iconMap`) and a unit (see `unitMap`). The creation
        // loop below will render a tile for every entry here.
        // ------------------------------------------------------------------
        const weatherVars = [
            "currentTemperature","feelsLike","map","tempMax","tempMin","sunarc",
            "humidity","pressure","pressureTrend","windSpeed","windGust","windDirection",
            "weatherDescription","cloudCoverage","rain1h","rain3h","snow1h","snow3h",
            "visibility","uvIndex","sunrise","sunset","dewPoint",
            "airQualityIndex","pm2_5","pm10","co","no2","o3",
            "pollenCount","fog"
        ];

        const blockOrder = [
            "currentTemperature",
            "feelsLike",
            "map",
            "tempMin",
            "tempMax",
            "sunarc",
            "humidity",
            "pressure",
            "pressureTrend",
            "windSpeed",
            "windGust",
            "windDirection",
            "weatherDescription",
            "cloudCoverage",
            "rain1h",
            "rain3h",
            "snow1h",
            "snow3h",
            "visibility",
            "uvIndex",
            "dewPoint",
            "airQualityIndex",
            "pm2_5",
            "pm10",
            "co",
            "no2",
            "o3",
            "pollenCount",
            "fog"
        ];

        const iconMap = {
            currentTemperature: 'fa-thermometer-half',
            feelsLike: 'fa-thermometer-half',
            tempMin: 'fa-thermometer-quarter',
            tempMax: 'fa-thermometer-full',
            humidity: 'fa-tint',
            pressure: 'fa-tachometer-alt',
            pressureTrend: 'fa-chart-line',
            weatherDescription: 'fa-cloud-sun',
            cloudCoverage: 'fa-cloud',
            rain1h: 'fa-cloud-showers-heavy',
            rain3h: 'fa-cloud-showers-heavy',
            snow1h: 'fa-snowflake',
            snow3h: 'fa-snowflake',
            windSpeed: 'fa-wind',
            windGust: 'fa-wind',
            windDirection: 'fa-compass',
            uvIndex: 'fa-sun',
            sunrise: 'fa-sun',
            sunset: 'fa-moon',
            visibility: 'fa-eye',
            dewPoint: 'fa-thermometer-quarter',
            airQualityIndex: 'fa-smog',
            pm10: 'fa-filter',
            pm2_5: 'fa-filter',
            co: 'fa-flask',
            no2: 'fa-flask',
            o3: 'fa-sun',
            pollenCount: 'fa-leaf',
            fog: 'fa-water', 
            map: 'fa-chart-area'
        };

        // Human readable labels and units
        const labelMap = {
            currentTemperature: 'Temperatur',
            feelsLike: 'Gef√ºhlt',
            tempMin: 'Min Temp',
            tempMax: 'Max Temp',
            humidity: 'Luftfeuchte',
            pressure: 'Luftdruck',
            pressureTrend: 'Drucktrend',
            weatherDescription: 'Beschreibung',
            cloudCoverage: 'Bew√∂lkung',
            rain1h: 'Regen (1h)',
            rain3h: 'Regen (3h)',
            snow1h: 'Schnee (1h)',
            snow3h: 'Schnee (3h)',
            windSpeed: 'Wind',
            windGust: 'Windb√∂e',
            windDirection: 'Windrichtung',
            uvIndex: 'UV-Index',
            sunrise: 'Sonnenaufgang',
            sunset: 'Sonnenuntergang',
            visibility: 'Sichtweite',
            dewPoint: 'Taupunkt',
            airQualityIndex: 'Luftqualit√§t',
            pm10: 'PM10',
            pm2_5: 'PM2.5',
            co: 'CO',
            no2: 'NO2',
            o3: 'O3',
            pollenCount: 'Pollen',
            fog: 'Nebel', 
            map: 'Karte'
        };

        const unitMap = {
            currentTemperature: '¬∞C',
            feelsLike: '¬∞C',
            tempMin: '¬∞C',
            tempMax: '¬∞C',
            humidity: '%',
            pressure: 'hPa',
            pressureTrend: '',
            weatherDescription: '',
            cloudCoverage: '%',
            rain1h: 'mm',
            rain3h: 'mm',
            snow1h: 'mm',
            snow3h: 'mm',
            windSpeed: 'km/h',
            windGust: 'km/h',
            windDirection: '¬∞',
            uvIndex: '',
            sunrise: '',
            sunset: '',
            visibility: 'm',
            dewPoint: '¬∞C',
            airQualityIndex: 'AQI',
            pm10: '¬µg/m¬≥',
            pm2_5: '¬µg/m¬≥',
            co: 'ppm',
            no2: 'ppb',
            o3: 'ppb',
            pollenCount: '',
            fog: ''
        };

        // Color series for cards (bunt)
        const colors = [
            '#ff6b6b', // red
            '#ffd93d', // yellow
            '#6bcB77', // green
            '#6b8cff', // blue
            '#a368ff', // violet
            '#ff8b6b', // orange
            '#42d392', // mint
            '#7dd3fc', // cyan
            '#f0a6ff', // pink
            '#ff8bd1'  // rose
        ];

        // Small constants
        const COMPASS_ICON_OFFSET = 45; // degrees to rotate to account for icon's default orientation

        // Erstelle Bl√∂cke f√ºr alle Variablen
        const elements = {};
        const dashboard = document.getElementById('dashboard');
        let draggedItem = null;

        // 1Ô∏è‚É£ Normale Variablen au√üer sunrise/sunset/map
        function createBlock(v, idx) {
            const block = document.createElement('div');
            block.className = 'weather-block';
            block.dataset.var = v;
            const color = colors[idx % colors.length];
            block.style.setProperty('--title-bg', color);

            const iconClass = iconMap[v] || 'fa-square';
            const label = labelMap[v] || v;
            const unit = unitMap[v] || '';

            if (v === 'windDirection') {
                block.innerHTML = `
                    <i class="fas ${iconClass} big-icon"></i>
                    <div class="card-title">${label}</div>
                    <div class="compass" aria-hidden="true">
                        <img class="compass-img" src="/static/images/458-4582952_360-compass-png-png-download-360-degree-compass.png" alt="compass">
                        <i class="fas fa-location-arrow compass-arrow" id="arrow-${v}" aria-hidden="true"></i>
                    </div>
                    <i class="fas fa-grip-lines drag-handle" draggable="true"></i>
                    <div class="card-value"><span id="${v}" class="value">--</span><span class="unit">${unit}</span></div>
                `;
            } else {
                block.innerHTML = `
                    <i class="fas ${iconClass} big-icon"></i>
                    <div class="card-title">${label}</div>
                    <i class="fas fa-grip-lines drag-handle" draggable="true"></i>
                    <div class="card-value"><span id="${v}" class="value">--</span><span class="unit">${unit}</span></div>
                `;
            }

            dashboard.appendChild(block);
            elements[v] = document.getElementById(v);
            addDragAndClick(block, v);
        }

        // 2Ô∏è‚É£ Gro√üer Map-/Custom-Block
        function createLargeBlock() {
            const block = document.createElement('div');
            block.className = 'weather-block big-block';
            block.dataset.var = 'customLargeBlock';
            const color = colors[2 % colors.length];
            block.style.setProperty('--title-bg', color);

            block.innerHTML = `
                <i class="fas fa-map big-icon"></i>
                <div class="card-title">Karte</div>
                <i class="fas fa-grip-lines drag-handle" draggable="true"></i>
                <div class="card-value">
                    <iframe id="customLargeBlockMapIframe" src="/static/map/map.html" style="width:100%; height:100%; border:none; border-radius:16px;"></iframe>
                </div>
            `;

            dashboard.appendChild(block);
            elements['customLargeBlock'] = document.getElementById('customLargeBlockMapIframe');
            addDragAndClick(block, 'customLargeBlock');
        }

        // 3Ô∏è‚É£ Sun Arc Block
        function createSunArcBlock() {
            const block = document.createElement('div');
            block.className = 'weather-block sun-arc-block';
            block.dataset.var = 'sunArc';
            block.id = 'sunArcContainer';
            const color = colors[1 % colors.length];
            block.style.setProperty('--title-bg', color);

            block.innerHTML = `
                <i class="fas fa-sun big-icon"></i>
                <div class="card-title">Sonnenverlauf</div>
                <i class="fas fa-grip-lines drag-handle" draggable="true"></i>
                <div id="sunArcPlot" class="sun-plot"></div>
                <div class="sun-legend">
                    <div class="sun-legend-left"><div class="sun-legend-label">Aufgang</div><div id="sunrise" class="value">--</div></div>
                    <div class="sun-legend-right"><div class="sun-legend-label">Untergang</div><div id="sunset" class="value">--</div></div>
                </div>
            `;

            dashboard.appendChild(block);
            elements['sunrise'] = document.getElementById('sunrise');
            elements['sunset'] = document.getElementById('sunset');
            addDragAndClick(block, 'sunArc');
        }

        // Hilfsfunktion f√ºr Drag & Click
        function addDragAndClick(block, v) {
            const handle = block.querySelector('.drag-handle');
            block.addEventListener('click', (e) => { if (e.target === handle) return; openHistory(v); });
            handle.addEventListener('dragstart', (e) => { 
                draggedItem = block; 
                block.classList.add('dragging'); 
                e.dataTransfer.effectAllowed = 'move'; 
                try { e.dataTransfer.setData('text/plain',''); } catch{} 
            });
            handle.addEventListener('dragend', (e) => { 
                draggedItem = null; 
                block.classList.remove('dragging'); 
            });
        }

        // ‚úÖ Erzeuge alle Bl√∂cke in blockOrder
        blockOrder.forEach((v, idx) => {
            if (v === 'sunrise' || v === 'sunset') return; // handled by Sun Arc Block
            if (v === 'map') {
                createLargeBlock();
            }else if (v === 'sunarc') {
                createSunArcBlock();
            }else {
                createBlock(v, idx);
            }
        });

        // DnD reordering
        // --------------------------------------------------------------
        // The grid uses HTML5 drag-and-drop on the `drag-handle` element.
        // Dragging inserts the dragged node before/after the hovered node,
        // enabling re-ordering of dashboard cards.
        // Note: This is a basic example; in production you'd also persist the
        // layout to localStorage or a backend so the positions remain stable.

        // DragStart & DragEnd sind bereits an jedem Block-Handle gesetzt
        // Nun das DragOver auf dem Dashboard:
        dashboard.addEventListener('dragover', (e) => {
            e.preventDefault();
            const target = e.target.closest('.weather-block');
            if (!target || target === draggedItem) return;

            const rect = target.getBoundingClientRect();
            const middleX = rect.left + rect.width / 2;

            if (e.clientX > middleX) {
                // Cursor rechts von der Mitte -> nach target einf√ºgen
                if (target.nextSibling !== draggedItem) {
                    dashboard.insertBefore(draggedItem, target.nextSibling);
                }
            } else {
                // Cursor links von der Mitte -> vor target einf√ºgen
                if (target !== draggedItem.nextSibling) {
                    dashboard.insertBefore(draggedItem, target);
                }
            }
        });

        // Optional: DragLeave zum Styling
        dashboard.addEventListener('dragleave', (e) => {
            // hier z.B. hovered class entfernen, wenn du optische Hinweise willst
        });


        // HISTORY MODAL functions
        const historyOverlay = document.getElementById('historyOverlay');
        const historyModal = document.getElementById('historyModal');
        const historyList = document.getElementById('historyList');
        const historyTitle = document.getElementById('historyTitle');
        const historyClose = document.getElementById('historyClose');

        const historyMap = {
            "currentTemperature": "currentTemperature_history",
            "current-temperature": "currentTemperature_history",

            "feelsLike": "feelsLike_history",
            "feels-like": "feelsLike_history",

            "tempMin": "tempMin_history",
            "temp-min": "tempMin_history",

            "tempMax": "tempMax_history",
            "temp-max": "tempMax_history",

            "humidity": "humidity_history",
            "windSpeed": "windSpeed_history",
            "wind-speed": "windSpeed_history",

            "pressure": "pressure_history"
        };

        function openHistory(variable) {
            const label = labelMap[variable] || variable;
            const unit = unitMap[variable] || '';
            const historyKey = variable + "_history";

            fetch('/weather')
                .then(res => res.json())
                .then(data => {

                    const container = document.querySelector(`.weather-block[data-var="${variable}"]`);
                    let color = '#ff5722';
                    if (container) color = getComputedStyle(container).getPropertyValue('--title-bg').trim() || color;

                    const currentStr = elements[variable]?.innerText || '--';
                    const currentVal = parseFloat(currentStr);

                    const xValues = [];
                    const yValues = [];

                    const history = data?.[historyKey];

                    if (history && Array.isArray(history) && history.length > 0) {
                        history.forEach(item => {
                            xValues.push(item.hr);
                            yValues.push(Number(item.value));
                        });

                        // Plot erstellen
                        const trace = {
                            x: xValues,
                            y: yValues,
                            mode: "lines+markers",
                            name: `${label} (${unit})`,
                            line: { color, width: 3 },
                            marker: { size: 10, color: color, line: { width: 1, color: "#fff" } }
                        };

                        const layout = {
                            title: { text: `${label} Verlauf`, font: { size: 16, color: "white" } },
                            xaxis: {
                                title: "Stunden relativ jetzt",
                                titlefont: { color: "white" },
                                tickfont: { color: "white" },
                                tickvals: xValues,
                                ticktext: xValues.map(hr => `${hr >= 0 ? '+' + hr : hr}h`),
                                gridcolor: "rgba(255,255,255,0.3)",
                                zeroline: false
                            },
                            yaxis: {
                                title: `${label} [${unit}]`,
                                titlefont: { color: "white" },
                                tickfont: { color: "white" },
                                gridcolor: "rgba(255,255,255,0.3)",
                                zeroline: false
                            },
                        margin: { t: 50, l: 50, r: 20, b: 50 },
                        font: { family: "Arial, sans-serif", size: 12 },
                        plot_bgcolor: "rgba(0,0,0,0)",
                        paper_bgcolor: "rgba(0,0,0,0)",
                        showlegend: false
                        };

                        let plotDiv = document.getElementById('weatherPlot');
                        if (!plotDiv) {
                            plotDiv = document.createElement('div');
                            plotDiv.id = 'weatherPlot';
                            plotDiv.style.width = '100%';
                            plotDiv.style.height = '100%';
                            historyModal.appendChild(plotDiv);
                        }

                        // Kleine Verz√∂gerung, damit das Div wirklich sichtbar ist
                        setTimeout(() => {
                            Plotly.newPlot(plotDiv, [trace], layout, { staticPlot: true, displayModeBar: false, responsive: true });
                        }, 5); // 5ms reicht meist

                        Plotly.newPlot(plotDiv, [trace], layout, { staticPlot: true, displayModeBar: false, responsive: true });

                    } else {
                        // Keine Historie ‚Üí Text anzeigen
                        let plotDiv = document.getElementById('weatherPlot');
                        if (!plotDiv) {
                            plotDiv = document.createElement('div');
                            plotDiv.id = 'weatherPlot';
                            plotDiv.style.width = '100%';
                            plotDiv.style.height = '100%';
                            plotDiv.style.display = 'flex';
                            plotDiv.style.alignItems = 'center';
                            plotDiv.style.justifyContent = 'center';
                            plotDiv.style.color = 'white';
                            plotDiv.style.fontSize = '16px';
                            historyModal.appendChild(plotDiv);
                        }
                        plotDiv.innerText = '‚ö†Ô∏è Keine Daten verf√ºgbar';
                    }

                    // Overlay anzeigen
                    historyOverlay.classList.remove('history-hidden');
                    historyOverlay.classList.add('history-show');
                });
        }

        function closeHistory() { historyOverlay.classList.remove('history-show'); historyOverlay.classList.add('history-hidden'); }
            historyClose.addEventListener('click', closeHistory);
            historyOverlay.addEventListener('click', (e)=> { if (e.target === historyOverlay) closeHistory(); });


        // Updates vom Server empfangen (SocketIO)
        socket.on('update', data => {
            console.log("üîî Update vom Server:", data);

            for (let key in data) {

                // Spezialfall: windDirection
                if (key === 'windDirection') {
                    const arrow = document.getElementById('arrow-windDirection');
                    const deg = parseFloat(data[key]);
                    if (!isNaN(deg) && arrow) arrow.style.transform = `translate(-50%, -50%) rotate(${deg - COMPASS_ICON_OFFSET}deg)`;
                }

                // Spezialf√§lle: sunrise & sunset ‚Üí Dezimalstunden
                if (key === 'sunrise' || key === 'sunset') {
                    const timeStr = data[key];
                    if (timeStr) {
                        const [h, m] = timeStr.split(':').map(Number);
                        window[key] = h + m / 60; // z.B. window.sunrise, window.sunset
                    }
                }

                if (key.endsWith('_history') && Array.isArray(data[key])) {
                    const container = document.getElementById(key); // z.‚ÄØB. <div id="currentTemperature_history"></div>
                    if (container) {
                        container.innerHTML = '';
                        data[key].forEach(entry => {
                            const p = document.createElement('p');
                            p.textContent = `Stunde ${entry.hr}: ${entry.value}`;
                            container.appendChild(p);
                        });
                    }
                }

                // Standard: alle Elemente aktualisieren
                if (elements[key]) {
                    elements[key].innerText = data[key];
                }

                // City anzeigen
                if (key === 'city') {
                    const cityDisplay = document.getElementById('cityDisplay');
                    if (cityDisplay) cityDisplay.innerText = data.city;

                    // Karte neu laden
                    const iframe = document.getElementById('customLargeBlockMapIframe');
                    if (iframe) {
                        const src = iframe.src.split('?')[0];
                        iframe.src = `${src}?ts=${new Date().getTime()}`;
                    }
                }

            }

            // Optional: Plot neu erzeugen, wenn Funktion existiert
            if (typeof window.generatePlot === 'function') window.generatePlot();
        });

        // Initiale Daten vom Server holen (fetch)
        fetch('/weather')
            .then(res => res.json())
            .then(data => {
                console.log("üì¶ Initiale Wetterdaten:", data);

                for (let key in data) {
                    // City
                    if (key === 'city') {
                        const cityDisplay = document.getElementById('cityDisplay');
                        if (cityDisplay) cityDisplay.innerText = data.city;
                    }

                    // windDirection
                    if (key === 'windDirection') {
                        const arrow = document.getElementById('arrow-windDirection');
                        const deg = parseFloat(data[key]);
                        if (!isNaN(deg) && arrow) arrow.style.transform = `translate(-50%, -50%) rotate(${deg - COMPASS_ICON_OFFSET}deg)`;
                    }

                    // sunrise & sunset
                    if (key === 'sunrise' || key === 'sunset') {
                        const timeStr = data[key];
                        if (timeStr) {
                            const [h, m] = timeStr.split(':').map(Number);
                            window[key] = h + m / 60;
                        }
                    }

                    // Alle anderen Elemente
                    if (elements[key]) elements[key].innerText = data[key];
                }

                if (typeof window.generatePlot === 'function') window.generatePlot();
            });

        // Stadt an Backend senden
        const cityInput = document.getElementById('cityInput');
        const cityButton = document.getElementById('cityButton');

        cityButton.addEventListener('click', () => {
            const city = cityInput.value.trim();
            if (city !== "") {
                socket.emit('cityInput', { city: city });
                cityInput.value = "";
            }
        });

        cityInput.addEventListener('keydown', (e) => {
            if (e.key === "Enter") {
                cityButton.click();
            }
        });

        // Menu logic (small)
        function formatRelativeTime(ts) {
            if (!ts) return '‚Äî';
            let date;
            if (typeof ts === 'number') date = new Date(ts * 1000);
            else date = new Date(ts);
            if (isNaN(date.getTime())) return '‚Äî';
            const diffSec = Math.round((Date.now() - date.getTime()) / 1000);
            if (diffSec < 60) return `${diffSec}s`;
            const diffMin = Math.round(diffSec / 60);
            if (diffMin < 60) return `${diffMin}m`;
            const diffHour = Math.round(diffMin / 60);
            if (diffHour < 24) return `${diffHour}std`;
            const diffDays = Math.round(diffHour / 24);
            return `${diffDays}d`;
        }
        async function updateApiStatus() {
            try {
                const res = await fetch('/status');
                // no global apiStatus; create dynamic per-api rows in #apiRows
                const apiRows = document.getElementById('apiRows');
                const API_ICON_MAP = { 'openweather': '/static/images/icon.svg', 'meteor': '/static/images/logo_white_cropped.png' };
                if (res.ok) {
                    // read optional JSON body
                    let body = null;
                    try { body = await res.json(); } catch (e) { body = null; }
                    console.debug('Status: OK');
                    // update per-api statuses if present
                    if (body && body.apis) {
                        // build/update a row for each API in the response
                        Object.keys(body.apis).forEach(k => {
                            const a = body.apis[k];
                            // Attempt to find an existing row for the API
                            let row = apiRows.querySelector(`.api-row[data-api="${k}"]`);
                            if (!row) {
                                row = document.createElement('div');
                                row.className = 'api-row d-flex align-items-center';
                                row.dataset.api = k;
                                // Julian: Hier noch den API Namen hinzugef√ºgt, unterscheidet zwischen API und CSV
                                row.innerHTML = `
                                    <div class="api-icon-wrap">
                                        <img src="${API_ICON_MAP[k] || '/static/images/icon.svg'}" class="api-icon" onerror="this.src='/static/images/icon.svg'" alt="${k}">
                                        <span class="status-dot offline"></span>
                                    </div>
                                    <div class="api-meta d-flex flex-column" style="margin-left:12px;">
                                        <div class="api-status-text">
                                            <strong class="api-name">${k}</strong> ¬∑ 
                                            <span class="api-status">‚Äî</span>
                                        </div>
                                        <div class="api-lastpolled api-last">‚Äî</div>
                                    </div>
                                `;
                                apiRows.appendChild(row);
                            }
                            const dot = row.querySelector('.status-dot');
                            const last = row.querySelector('.api-last');
                            const statusNode = row.querySelector('.api-status');
                            if (a.status === 'ok') {
                                dot.classList.remove('offline', 'error'); dot.classList.add('ok');
                                statusNode.innerText = 'OK'; statusNode.classList.remove('error'); statusNode.classList.add('ok');
                            } else {
                                dot.classList.remove('offline', 'ok'); dot.classList.add('error');
                                statusNode.innerText = 'ERROR'; statusNode.classList.remove('ok'); statusNode.classList.add('error');
                            }
                            if (last) last.innerText = a.lastPolled ? formatRelativeTime(a.lastPolled) : '‚Äî';
                        });
                        // remove any rows for APIs that no longer exist in the response
                        Array.from(apiRows.querySelectorAll('.api-row')).forEach(r => {
                            const nm = r.dataset.api;
                            if (!body.apis[nm]) r.remove();
                        });
                    } else if (body && body.lastPolled) {
                        const txt = formatRelativeTime(body.lastPolled);
                        // update all rows existing in the menu
                        apiRows.querySelectorAll('.api-row').forEach(r => {
                            const last = r.querySelector('.api-last');
                            if (last) last.innerText = txt;
                        });
                    } else {
                        apiRows.querySelectorAll('.api-row').forEach(r => {
                            const last = r.querySelector('.api-last');
                            if (last) last.innerText = 'gerade eben';
                        });
                    }
                } else {
                    let body = null;
                    try { body = await res.json(); } catch (e) { body = null; }
                    console.debug('Status: ERROR');
                    // mark all available rows as error
                    apiRows.querySelectorAll('.api-row').forEach(r => {
                        const dot = r.querySelector('.status-dot');
                        const last = r.querySelector('.api-last');
                        const statusNode = r.querySelector('.api-status');
                        if (dot) { dot.classList.remove('ok'); dot.classList.add('error'); }
                        if (statusNode) { statusNode.innerText = 'ERROR'; statusNode.classList.remove('ok'); statusNode.classList.add('error'); }
                        if (last) last.innerText = (body && body.lastPolled) ? formatRelativeTime(body.lastPolled) : '‚Äî';
                    });
                }
            } catch (err) {
                // mark per-apis as offline on error
                apiRows.querySelectorAll('.api-row').forEach(r => {
                    const dot = r.querySelector('.status-dot');
                    const last = r.querySelector('.api-last');
                    const statusNode = r.querySelector('.api-status');
                    if (dot) { dot.classList.remove('ok'); dot.classList.add('offline'); }
                    if (statusNode) { statusNode.innerText = '‚Äî'; statusNode.classList.remove('ok', 'error'); }
                    if (last) last.innerText = '‚Äî';
                });
            }
        }
        updateApiStatus();
        setInterval(updateApiStatus, 15000);
    </script>
</body>

</html>
