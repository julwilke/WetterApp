<!--
 ========================================================
 WetterApp Dashboard — HTML5 Hauptseite (v1.0.5)
 ========================================================
 Responsive Dashboard mit dynamischen Wetter-Kacheln,
 Verlaufs-Modal und Echtzeit-Updates über SocketIO.
 ========================================================
-->

<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Dashboard - WetterApp</title>
    
    <!-- Externe Ressourcen: Google Fonts, FontAwesome Icons, Socket.IO -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito:200,300,400,600,700,800,900">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" crossorigin="anonymous">
    
    <!-- Projektspezifische Stile (konsolidiert, Bootstrap entfernt) -->
    <link rel="stylesheet" href="/static/styles.css">
    
    <!-- Real-Time Kommunikation mit Backend -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>

<body id="page-top">
    <div id="wrapper">
        <!--
         ================================================
         SEITENLEISTE (SIDEBAR)
         ================================================
         Linke Navigation mit Branding und Menü
        -->
        <nav id="sidebar" class="navbar navbar-dark align-items-start sidebar sidebar-dark accordion bg p-0">
            <div class="container-fluid d-flex flex-column p-0"><a class="navbar-brand d-flex justify-content-center align-items-center sidebar-brand m-0" href="#" style="text-decoration: none;">
                    <div class="sidebar-brand-icon rotate-n-15"><i class="fas fa-cloud-sun"></i></div>
                    <div class="sidebar-brand-text mx-3"><span>Wetter-App</span></div>
                </a>
                <!-- Hauptmenü: Navigationslinks -->
                <ul class="navbar-nav text-light" id="accordionSidebar">
                    <li class="nav-item"><a class="nav-link active" href="/"><i class="fas fa-tachometer-alt"></i><span>Dashboard</span></a></li>                    
                </ul>
                <div class="text-center d-none d-md-inline"><button class="btn rounded-circle border-0" id="sidebarToggle" type="button"></button></div>
            </div>
        </nav>
        
        <div class="d-flex flex-column" id="content-wrapper">
            <div id="content">
                <!--
                 ================================================
                 NAVIGATIONSLEISTE (NAVBAR)
                 ================================================
                 Oben: Stadtsuche, API-Status, GitHub-Link
                -->
                <nav id="navbar" class="navbar navbar-light navbar-expand shadow mb-4 topbar static-top">
                    <div class="container-fluid">
                        <button class="btn btn-link d-md-none rounded-circle me-3" id="sidebarToggleTop" type="button"><i class="fas fa-bars"></i></button>
                        
                        <!-- Suchformular für Stadteingabe -->
                        <form class="d-none d-sm-inline-block me-auto ms-md-3 my-2 my-md-0 mw-100 navbar-search navbar-form" >
                            <div class="input-group"><input id="cityInput" class="bg-light form-control border-0 small" type="text" placeholder="Suche nach Stadt..."><button id="cityButton" class="btn btn-primary" type="button"><i class="fas fa-search"></i></button></div>
                        </form>
                        
                        <ul class="navbar-nav flex-nowrap ms-auto">
                            <!-- API-Status Dropdown -->
                            <li class="nav-item dropdown no-arrow mx-1">
                                <div class="nav-item dropdown no-arrow"><a class="dropdown-toggle nav-link nav-icon no-arrow" aria-expanded="false" data-bs-toggle="dropdown" href="#"><i class="fab fa-cloudscale fa-fw"></i></a>
                                            <div class="dropdown-menu dropdown-menu-end bg-dark border-dark dropdown-list animated--grow-in">
                                                <h6 class="dropdown-header border-dark menu-header" style="margin-top: 0px; color: white">API-Status</h6>
                                                <div class="menu-padding">
                                                    <!-- apiRows wird dynamisch durch updateApiStatus() gefüllt -->
                                                    <div id="apiRows" class="api-rows d-flex flex-column" style="gap:10px;">
                                                        <!-- Populiert via JavaScript: /status → body.apis -->
                                                    </div>
                                                </div>
                                            </div>
                                </div>
                            </li>
                            <!-- GitHub-Link -->
                            <li class="nav-item dropdown no-arrow"><a class="nav-link nav-icon" href="https://github.com/julwilke/WetterApp" target="_blank"><i class="fab fa-github"></i></a></li>
                        </ul>
                    </div>
                </nav>

                <div class="container-fluid">
                    <!-- Seitentitel (Stadtname) -->
                    <div class="d-sm-flex justify-content-between align-items-center mb-4">
                        <h3 class="mb-0" id="cityDisplay">--</h3>
                    </div>

                    <!--
                     ================================================
                     DASHBOARD GRID
                     ================================================
                     Dynamisch generierte Wetter-Kacheln
                     Die JavaScript lädt die Kacheln basierend auf der
                     weatherVars Liste und blockOrder.
                    -->
                    <div id="dashboard" class="row">
                        <!-- Kacheln werden via Client-Side JS injiziert -->
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <footer class="sticky-footer">
                <div class="container my-auto">
                    <div class="text-center my-auto copyright">Copyright © PKI B1-3 WetterApp 2025</div>
                </div>
            </footer>
        </div>
        
        <!-- Scroll-zu-Oben Button -->
        <a class="border rounded d-inline scroll-to-top" href="#page-top"><i class="fas fa-angle-up"></i></a>
    </div>
   
    <!--
     ========================================================
     VERLAUFS-MODAL (HISTORY/FORECAST OVERLAY)
     ========================================================
     Überlagerndes Modal zur Anzeige historischer und
     prognostizierter Wetterdaten mit Graphiken.
    -->
    <div id="historyOverlay" class="history-hidden">
      <div id="historyModal">
        <!-- Modal-Header mit Schließen-Button -->
        <div id="historyHeader">
          <strong id="historyTitle">Verlauf</strong>
          <button id="historyClose" type="button">✕</button>
        </div>

        <!-- Steuerelemente: Tage-Eingabe und Reload-Button -->
        <div id="historyControls">
          <label class="history-label">
            Tage:
            <input id="historyDays" type="number" min="1" max="14" value="7">
          </label>

          <button id="historyReload" type="button">Neu laden</button>
          <span id="historyInfo"></span>
        </div>

        <!-- Container für dynamisch geladene Plot-Bilder -->
        <div id="weatherPlot"></div>
      </div>
    </div>


    <!--
     ========================================================
     EXTERNE SKRIPTE UND INITIALISIERUNG
     ========================================================
    -->
    
    <!-- Bootstrap-Initialisierung (Animations, Charts) -->
    <script src="/static/js/bs-init.js"></script>
    
    <!-- Plotly-Bibliothek für Sun-Arc Visualisierung -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <!-- Projekt-Logik: Sonnenbahn-Generator und Plot-Hilfsfunktionen -->
    <script src="/static/script.js"></script>

    <!-- Projekt-Logik: Taskbar -->
    <script src="/static/js/theme.js"></script>

    <!--
     ========================================================
     INLINE DASHBOARD-SKRIPT
     ========================================================
     Hauptlogik für:
     - Wetter-Kachel-Rendering
     - SocketIO Echtzeit-Updates
     - History/Forecast Modal
     - Drag-and-Drop Neuanordnung
    -->
    <script>
        // Real-Time Kommunikation mit Backend
        const socket = io();

        const form = document.querySelector('.navbar-form');
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            cityButton.click();
        });

        /**
         * WETTER-VARIABLEN KONFIGURATION
         * Anzeigereihenfole, Icons, Labels und Einheiten definieren die UI
         */

        const weatherVars = [
            "currentTemperature","feelsLike","map","tempMax","tempMin","sunarc",
            "humidity","pressure","pressureTrend","windSpeed","windGust","windDirection",
            "weatherDescription","cloudCoverage","rain1h","rain3h","snow1h","snow3h",
            "visibility","uvIndex","sunrise","sunset","dewPoint",
            "airQualityIndex","pm2_5","pm10","co","no2","o3",
            "pollenCount","fog"
        ];

        // Anzeigereihenfole im Dashboard
        const blockOrder = [
            "currentTemperature",
            "feelsLike",
            "map",
            "tempMin",
            "tempMax",
            "sunarc",
            "humidity",
            "pressure",
            "pressureTrend",
            "windSpeed",
            "windGust",
            "windDirection",
            "weatherDescription",
            "cloudCoverage",
            "rain1h",
            "rain3h",
            "snow1h",
            "snow3h",
            "visibility",
            "uvIndex",
            "dewPoint",
            "airQualityIndex",
            "pm2_5",
            "pm10",
            "co",
            "no2",
            "o3",
            "pollenCount",
            "fog"
        ];

        /**
         * Icon-Zuordnungen für Wettervariablen (FontAwesome Icons)
         */
        const iconMap = {
            currentTemperature: 'fa-thermometer-half',
            feelsLike: 'fa-thermometer-half',
            tempMin: 'fa-thermometer-quarter',
            tempMax: 'fa-thermometer-full',
            humidity: 'fa-tint',
            pressure: 'fa-tachometer-alt',
            pressureTrend: 'fa-chart-line',
            weatherDescription: 'fa-cloud-sun',
            cloudCoverage: 'fa-cloud',
            rain1h: 'fa-cloud-showers-heavy',
            rain3h: 'fa-cloud-showers-heavy',
            snow1h: 'fa-snowflake',
            snow3h: 'fa-snowflake',
            windSpeed: 'fa-wind',
            windGust: 'fa-wind',
            windDirection: 'fa-compass',
            uvIndex: 'fa-sun',
            sunrise: 'fa-sun',
            sunset: 'fa-moon',
            visibility: 'fa-eye',
            dewPoint: 'fa-thermometer-quarter',
            airQualityIndex: 'fa-smog',
            pm10: 'fa-filter',
            pm2_5: 'fa-filter',
            co: 'fa-flask',
            no2: 'fa-flask',
            o3: 'fa-sun',
            pollenCount: 'fa-leaf',
            fog: 'fa-water', 
            map: 'fa-chart-area'
        };

        // Labels für die Cards
        const labelMap = {
            currentTemperature: 'Temperatur',
            feelsLike: 'Gefühlt',
            tempMin: 'Min Temp',
            tempMax: 'Max Temp',
            humidity: 'Luftfeuchte',
            pressure: 'Luftdruck',
            pressureTrend: 'Drucktrend',
            weatherDescription: 'Beschreibung',
            cloudCoverage: 'Bewölkung',
            rain1h: 'Regen (1h)',
            rain3h: 'Regen (3h)',
            snow1h: 'Schnee (1h)',
            snow3h: 'Schnee (3h)',
            windSpeed: 'Wind',
            windGust: 'Windböe',
            windDirection: 'Windrichtung',
            uvIndex: 'UV-Index',
            sunrise: 'Sonnenaufgang',
            sunset: 'Sonnenuntergang',
            visibility: 'Sichtweite',
            dewPoint: 'Taupunkt',
            airQualityIndex: 'Luftqualität',
            pm10: 'PM10',
            pm2_5: 'PM2.5',
            co: 'CO',
            no2: 'NO2',
            o3: 'O3',
            pollenCount: 'Pollen',
            fog: 'Nebel', 
            map: 'Karte'
        };

        /**
         * Einheiten für die Wetterwerte
         * Werden neben dem Wert angezeigt
         */
        const unitMap = {
            currentTemperature: '°C',
            feelsLike: '°C',
            tempMin: '°C',
            tempMax: '°C',
            humidity: '%',
            pressure: 'hPa',
            pressureTrend: '',
            weatherDescription: '',
            cloudCoverage: '%',
            rain1h: 'mm',
            rain3h: 'mm',
            snow1h: 'mm',
            snow3h: 'mm',
            windSpeed: 'km/h',
            windGust: 'km/h',
            windDirection: '°',
            uvIndex: '',
            sunrise: '',
            sunset: '',
            visibility: 'm',
            dewPoint: '°C',
            airQualityIndex: 'AQI',
            pm10: 'µg/m³',
            pm2_5: 'µg/m³',
            co: 'ppm',
            no2: 'ppb',
            o3: 'ppb',
            pollenCount: '',
            fog: ''
        };

        /**
         * Farbpalette für Kachel-Titel (10 unterschiedliche Farben)
         */
        const colors = [
            '#ff6b6b', // Rot
            '#ffd93d', // Gelb
            '#6bcB77', // Grün
            '#6b8cff', // Blau
            '#a368ff', // Violett
            '#ff8b6b', // Orange
            '#42d392', // Mint
            '#7dd3fc', // Cyan
            '#f0a6ff', // Pink
            '#ff8bd1'  // Rose
        ];

        /**
         * Konstanten für UI-Verhalten
         */
        const COMPASS_ICON_OFFSET = 45; // Grad zur Ausrichtung des Icons

        // ========== DOM-Elemente und Initalisierung ==========
        const elements = {};
        const dashboard = document.getElementById('dashboard');
        let draggedItem = null;

        /**
         * Prüfe, ob Variable Zeitreihen-Daten hat
         * Wird für History-Indikator Icon verwendet
         */
        function isTimeseriesVariable(v) {
            const timeseriesEnabled = new Set([
                "currentTemperature",
                "humidity",
                "windSpeed"
            ]);
            return timeseriesEnabled.has(v);
        }

        /**
         * Erstelle normale Wetter-Kacheln
         */
        function createBlock(v, idx) {
            const block = document.createElement('div');
            block.className = 'weather-block';
            block.dataset.var = v;
            const color = colors[idx % colors.length];
            block.style.setProperty('--title-bg', color);

            const iconClass = iconMap[v] || 'fa-square';
            const label = labelMap[v] || v;
            const unit = unitMap[v] || '';

            /**
             * Verlaufs-Indikator: Zeigt an, ob Zeitreihen-Daten verfügbar sind
             */
            const hasHistoryData = isTimeseriesVariable(v);
            const historyIndicatorHTML = hasHistoryData 
                ? `<i class="fas fa-history history-indicator" title="Verlaufsdaten verfügbar"></i>` 
                : '';

            if (v === 'windDirection') {
                block.innerHTML = `
                    <i class="fas ${iconClass} big-icon"></i>
                    <div class="card-title">${label}</div>
                    ${historyIndicatorHTML}
                    <div class="compass" aria-hidden="true">
                        <img class="compass-img" src="/static/images/458-4582952_360-compass-png-png-download-360-degree-compass.png" alt="compass">
                        <i class="fas fa-location-arrow compass-arrow" id="arrow-${v}" aria-hidden="true"></i>
                    </div>
                    <i class="fas fa-grip-lines drag-handle" draggable="true"></i>
                    <div class="card-value"><span id="${v}" class="value">--</span><span class="unit">${unit}</span></div>
                `;
            } else {
                block.innerHTML = `
                    <i class="fas ${iconClass} big-icon"></i>
                    <div class="card-title">${label}</div>
                    ${historyIndicatorHTML}
                    <i class="fas fa-grip-lines drag-handle" draggable="true"></i>
                    <div class="card-value"><span id="${v}" class="value">--</span><span class="unit">${unit}</span></div>
                `;
            }

            dashboard.appendChild(block);
            elements[v] = document.getElementById(v);
            addDragAndClick(block, v);
        }

        // 2️⃣ Große Karte
        function createLargeBlock() {
            const block = document.createElement('div');
            block.className = 'weather-block big-block';
            block.dataset.var = 'customLargeBlock';
            const color = colors[2 % colors.length];
            block.style.setProperty('--title-bg', color);

            block.innerHTML = `
                <i class="fas fa-map big-icon"></i>
                <div class="card-title">Karte</div>
                <i class="fas fa-grip-lines drag-handle" draggable="true"></i>
                <div class="card-value">
                    <iframe id="customLargeBlockMapIframe" src="/static/map/map.html" style="width:100%; height:100%; border:none; border-radius:16px;"></iframe>
                </div>
            `;

            dashboard.appendChild(block);
            elements['customLargeBlock'] = document.getElementById('customLargeBlockMapIframe');
            addDragAndClick(block, 'customLargeBlock');
        }

        // 3️⃣ Sun Arc Block
        function createSunArcBlock() {
            const block = document.createElement('div');
            block.className = 'weather-block sun-arc-block';
            block.dataset.var = 'sunArc';
            block.id = 'sunArcContainer';
            const color = colors[1 % colors.length];
            block.style.setProperty('--title-bg', color);

            block.innerHTML = `
                <i class="fas fa-sun big-icon"></i>
                <div class="card-title">Sonnenverlauf</div>
                <i class="fas fa-grip-lines drag-handle" draggable="true"></i>
                <div id="sunArcPlot" class="sun-plot"></div>
                <div class="sun-legend">
                    <div class="sun-legend-left"><div class="sun-legend-label">Aufgang</div><div id="sunrise" class="value">--</div></div>
                    <div class="sun-legend-right"><div class="sun-legend-label">Untergang</div><div id="sunset" class="value">--</div></div>
                </div>
            `;

            dashboard.appendChild(block);
            elements['sunrise'] = document.getElementById('sunrise');
            elements['sunset'] = document.getElementById('sunset');
            addDragAndClick(block, 'sunArc');
        }


        /**
         * Drag & Click Handler für Kacheln
         * - Drag-and-Drop zum Neuordnen
         * - Klick öffnet History/Forecast Modal
         */
        function addDragAndClick(block, v) {
            const handle = block.querySelector('.drag-handle');

            // Kacheln mit Verlaufs-/Prognose-Daten
            // (nur Variablen mit zeitlichen Daten)
            const timeseriesEnabled = new Set([
                "currentTemperature",
                "humidity",
                "windSpeed"
            ])

            block.addEventListener('click', (e) => { 
                if (e.target === handle) return; 
                
                if (v == 'customLargeBlock' || v == 'map' || v == 'sunArc') return; // s.o.: Damit diese drei nicht auch history und forecast laden

                // Nur Kacheln öffnen, für die du Timeseries angebunden hast
                if (!timeseriesEnabled.has(v)) return;

                openHistoryAndForecast(v); 
            });

            handle.addEventListener('dragstart', (e) => { 
                draggedItem = block; 
                block.classList.add('dragging'); 
                e.dataTransfer.effectAllowed = 'move'; 
                try { e.dataTransfer.setData('text/plain',''); } catch{} 
            });
            handle.addEventListener('dragend', (e) => { 
                draggedItem = null; 
                block.classList.remove('dragging'); 
            });
        }

        /**
         * Alle Kacheln rendern nach blockOrder
         */
        blockOrder.forEach((v, idx) => {
            if (v === 'sunrise' || v === 'sunset') return;

            if (v === 'map') {
                createLargeBlock();
            }else if (v === 'sunarc') {
                createSunArcBlock();
            }else {
                createBlock(v, idx);
            }
        });

        // DnD reordering
        // --------------------------------------------------------------
        // The grid uses HTML5 drag-and-drop on the `drag-handle` element.
        // Dragging inserts the dragged node before/after the hovered node,
        // enabling re-ordering of dashboard cards.
        // Note: This is a basic example; in production you'd also persist the
        // layout to localStorage or a backend so the positions remain stable.

        // DragStart & DragEnd sind bereits an jedem Block-Handle gesetzt
        // Nun das DragOver auf dem Dashboard:
        dashboard.addEventListener('dragover', (e) => {
            e.preventDefault();
            const target = e.target.closest('.weather-block');
            if (!target || target === draggedItem) return;

            const rect = target.getBoundingClientRect();
            const middleX = rect.left + rect.width / 2;

            if (e.clientX > middleX) {
                // Cursor rechts von der Mitte → nach target einfügen
                if (target.nextSibling !== draggedItem) {
                    dashboard.insertBefore(draggedItem, target.nextSibling);
                }
            } else {
                // Cursor links von der Mitte → vor target einfügen
                if (target !== draggedItem.nextSibling) {
                    dashboard.insertBefore(draggedItem, target);
                }
            }
        });

        // Optional: DragLeave für visuelle Hinweise (TODO: Bei Bedarf aktivieren)
        dashboard.addEventListener('dragleave', (e) => {
            // Beispiel: CSS-Klasse entfernen für optische Rückmeldung
        });



        /**
         * ========================================================
         * VERLAUFS- & PROGNOSE-MODAL (History/Forecast)
         * ========================================================
         * Version: 1.0.0
         * 
         * Funktionalität:
         * - Backend liefert MatPlotLib-PNG für Verlauf und Prognose
         * - Browser lädt dynamisch: /history_plot.png, /forecast_plot.png
         * - Modal öffnet sich beim Klick auf Zeitreihen-Kacheln
         */

        const historyOverlay = document.getElementById('historyOverlay');
        const historyModal = document.getElementById('historyModal');
        const historyList = document.getElementById('historyList');
        const historyTitle = document.getElementById('historyTitle');
        const historyClose = document.getElementById('historyClose');
        const historyReload = document.getElementById('historyReload')

        /**
         * ========================================================
         * Variable Mapping: Frontend → OpenMeteo Backend
         * ========================================================
         * Ordnet Wetter-Variablen ihren OpenMeteo-Äquivalenten zu
         */
        const openMeteoVarMap = {
            currentTemperature: "temperature_2m",
            //feelsLike:          "temperature_2m",
            //tempMin:            "temperature_2m",
            //tempMax:            "temperature_2m",
            humidity:           "relative_humidity_2m",
            windSpeed:          "wind_speed_10m"
        };

        // Für History/Forecast Modal: Zuletzt angeklickte Variable
        let lastCardVar = null;              

        // Hilfsfunktion: Zentrierte Nachricht anzeigen
        function setCenteredMessage(container, text) {
            container.innerHTML = "";
            container.style.display = "flex";
            container.style.alignItems = "center";
            container.style.justifyContent = "center";
            container.style.color = "white";
            container.style.fontSize = "16px";
            container.innerText = text;
        }

        // Hilfsfunktion: Erstellt eine Sektion Überschrift
        function makeSectionTitle(text, margin) {
            const el = document.createElement("div");
            el.style.color = "white";
            el.style.fontWeight = "600";
            el.style.margin = margin || "4px 0";
            el.innerText = text;
            return el;
        }

        // Hilfsfunktion: Plot-Bild Element erstellen
        function makePlotImage(altText) {
            const img = document.createElement("img");
            img.alt = altText;
            img.style.width = "100%";
            img.style.objectFit = "contain";
            img.style.borderRadius = "10px";
            return img;
        }


        /**
         * Öffne History/Forecast Modal
         * Lädt Graphiken basierend auf ausgewählte Variable
         */
        function openHistoryAndForecast(variable) {
            lastCardVar = variable;

            const label = (typeof labelMap !== "undefined" && labelMap[variable]) ? labelMap[variable] : variable;

            // Tage aus Input lesen
            const daysInput = document.getElementById("historyDays");
            let days = 7;

            if (daysInput) {
                const parsed = parseInt(daysInput.value, 10);
                if (!isNaN(parsed) && parsed >= 1 && parsed <= 14) days = parsed;
            }

            // Stadt aus UI holen (steht oben links im Dashboard)
            const city = (document.getElementById("cityDisplay")?.innerText || "").trim();

            // Welchen OpenMeteo-Wert laden?
            const meteoVar = openMeteoVarMap[variable];

            // Titel im Modal setzen
            if (historyTitle) historyTitle.innerText = `Zeitverlauf: ${label}`;

            const plotDiv = document.getElementById("weatherPlot");
            plotDiv.innerHTML = ""; // sauber leeren

            plotDiv.style.display = "block";
            plotDiv.innerHTML = "";

            // Falls kein Wert für die Kachel gefunden wurde: Text setzen
            if (!meteoVar) {
                setCenteredMessage(plotDiv, "⚠️ Für diese Kachel ist noch keine History/Forecast angebunden.");
            }
            else {

                // War notwendig, damit der Browser nicht ein altes Bild zeigt. Zeitstempel "jetzt" setzen
                const bust = Date.now()



                // ===== 1) HISTORY =====
                
                const hTitle = makeSectionTitle("Vergangenheit");        
                const historyImg = makePlotImage(`History Plot: ${label}`);    
                
                // Bild reinladen
                historyImg.src =
                `/history_plot.png?var=${encodeURIComponent(meteoVar)}` +
                `&days=${encodeURIComponent(days)}` +
                `&city=${encodeURIComponent(city)}` +
                `&v=${bust}`;

                historyImg.onerror = () => {
                    setCenteredMessage(plotDiv, "⚠️ Keine History-Plot-Daten verfügbar (Backend/API).");
                };



                // ===== 2) FORECAST =====
                const fTitle = makeSectionTitle("Vorhersage", "12px 0 4px 0");     
                const forecastImg = makePlotImage(`Forecast Plot: ${label}`);
                
                // Forecast nutzt das gleiche days-Inputfeld
                const forecastDays = days; // alternativ: 14 als Standard?

                forecastImg.src =
                    `/forecast_plot.png?var=${encodeURIComponent(meteoVar)}` +
                    `&days=${encodeURIComponent(forecastDays)}` +
                    `&city=${encodeURIComponent(city)}` +
                    `&v=${bust}`;

                forecastImg.onerror = () => {
                    const warn = document.createElement("div");
                    warn.style.color = "white";
                    warn.style.opacity = "0.9";
                    warn.style.marginTop = "6px";
                    warn.innerText = "⚠️ Keine Forecast-Plot-Daten verfügbar (Backend/API).";
                    plotDiv.appendChild(warn);
                };



                // ===== BEIDE BILDER UNTEREINANDER EINHÄNGEN
                plotDiv.appendChild(hTitle);
                plotDiv.appendChild(historyImg);
                plotDiv.appendChild(fTitle);
                plotDiv.appendChild(forecastImg);

                const info = document.getElementById("historyInfo");

                if (info) info.innerText = `${city} · History + Forecast · ${days} Tage · Matplotlib`;
            }

            // Modal anzeigen
            if (historyOverlay) {
                historyOverlay.classList.remove("history-hidden");
                historyOverlay.classList.add("history-show");
            }
            }           
           
        // Reload Button einmalig für beide
        if (historyReload) {
        historyReload.addEventListener("click", () => {
            if (lastCardVar) openHistoryAndForecast(lastCardVar);
        });
        }

        // Modal schließen-Funktion
        function closeHistory() {
            if (!historyOverlay) return;
            historyOverlay.classList.remove("history-show");
            historyOverlay.classList.add("history-hidden");
            }

        if (historyClose) historyClose.addEventListener("click", closeHistory);

        if (historyOverlay) {
            historyOverlay.addEventListener("click", (e) => {
                if (e.target === historyOverlay) closeHistory();
            });
        }

        /**
         * ENDE: Verlaufs-/Prognose-Modal
         */


        /**
         * Echtzeit-Updates vom Server (SocketIO)
         */
        socket.on('update', data => {

            for (let key in data) {

                // Spezialfall: windDirection
                if (key === 'windDirection') {
                    const arrow = document.getElementById('arrow-windDirection');
                    const deg = parseFloat(data[key]);
                    if (!isNaN(deg) && arrow) arrow.style.transform = `translate(-50%, -50%) rotate(${deg - COMPASS_ICON_OFFSET}deg)`;
                }

                // Spezialfälle: sunrise & sunset → Dezimalstunden
                if (key === 'sunrise' || key === 'sunset') {
                    const timeStr = data[key];
                    if (timeStr) {
                        const [h, m] = timeStr.split(':').map(Number);
                        window[key] = h + m / 60; // z.B. window.sunrise, window.sunset
                    }
                }

                if (key.endsWith('_history') && Array.isArray(data[key])) {
                    const container = document.getElementById(key); // z. B. <div id="currentTemperature_history"></div>
                    if (container) {
                        container.innerHTML = '';
                        data[key].forEach(entry => {
                            const p = document.createElement('p');
                            p.textContent = `Stunde ${entry.hr}: ${entry.value}`;
                            container.appendChild(p);
                        });
                    }
                }

                // Standard: alle Elemente aktualisieren
                if (elements[key]) {
                    elements[key].innerText = data[key];
                }

                // City anzeigen
                if (key === 'city') {
                    const cityDisplay = document.getElementById('cityDisplay');
                    if (cityDisplay) cityDisplay.innerText = data.city;

                    // Karte neu laden
                    const iframe = document.getElementById('customLargeBlockMapIframe');
                    if (iframe) {
                        const src = iframe.src.split('?')[0];
                        iframe.src = `${src}?ts=${new Date().getTime()}`;
                    }
                }

            }

            // Optional: Plot neu erzeugen, wenn Funktion existiert
            if (typeof window.generatePlot === 'function') window.generatePlot();
        });

        // Initiale Wetterdaten holen vom Server
        fetch('/weather')
            .then(res => res.json())
            .then(data => {

                for (let key in data) {
                    // Stadt-Anzeige
                    if (key === 'city') {
                        const cityDisplay = document.getElementById('cityDisplay');
                        if (cityDisplay) cityDisplay.innerText = data.city;
                    }

                    // Windrichtungs-Kompass
                    if (key === 'windDirection') {
                        const arrow = document.getElementById('arrow-windDirection');
                        const deg = parseFloat(data[key]);
                        if (!isNaN(deg) && arrow) arrow.style.transform = `translate(-50%, -50%) rotate(${deg - COMPASS_ICON_OFFSET}deg)`;
                    }

                    // Sonnenauf- und -untergang mit Uhrzeit
                    if (key === 'sunrise' || key === 'sunset') {
                        const timeStr = data[key];
                        if (timeStr) {
                            const [h, m] = timeStr.split(':').map(Number);
                            window[key] = h + m / 60;
                        }
                    }

                    // Alle anderen Elemente
                    if (elements[key]) elements[key].innerText = data[key];
                }

                if (typeof window.generatePlot === 'function') window.generatePlot();
            });

        // Stadt an Backend senden
        const cityInput = document.getElementById('cityInput');
        const cityButton = document.getElementById('cityButton');

        cityButton.addEventListener('click', () => {
            const city = cityInput.value.trim();
            if (city !== "") {
                socket.emit('cityInput', { city: city });
                cityInput.value = "";
            }
        });

        cityInput.addEventListener('keydown', (e) => {
            if (e.key === "Enter") {
                cityButton.click();
            }
        });

        /**
         * Formatierung für relative Zeit (z.B. "vor 2 Min")
         */
        function formatRelativeTime(ts) {
            if (!ts) return '—';
            let date;
            if (typeof ts === 'number') date = new Date(ts * 1000);
            else date = new Date(ts);
            if (isNaN(date.getTime())) return '—';
            const diffSec = Math.round((Date.now() - date.getTime()) / 1000);
            if (diffSec < 60) return `${diffSec}s`;
            const diffMin = Math.round(diffSec / 60);
            if (diffMin < 60) return `${diffMin}m`;
            const diffHour = Math.round(diffMin / 60);
            if (diffHour < 24) return `${diffHour}Std`;
            const diffDays = Math.round(diffHour / 24);
            return `${diffDays}T`;
        }

        /**
         * ========================================================
         * API STATUS UPDATE
         * ========================================================
         * Ruft /status Endpoint ab und zeigt API-Verbindungsstatus
         * an. Aktualisiert dynamisch die apiRows.
         */
        async function updateApiStatus() {
            try {
                const res = await fetch('/status');
                const apiRows = document.getElementById('apiRows');

                // Icon-Zuordnung für API-Provider
                const API_ICON_MAP = {'openweather': '/static/images/icon.svg', 'csv': '/static/images/csv.png'};
                if (res.ok) {
                    // Optional JSON Body auslesen
                    let body = null;
                    try { body = await res.json(); } catch (e) { body = null; }
                    console.debug('Status: OK');
                    // API-Status wenn vorhanden
                    if (body && body.apis) {
                        // build/update a row for each API in the response
                        Object.keys(body.apis).forEach(k => {
                            const a = body.apis[k];
                            // Attempt to find an existing row for the API
                            let row = apiRows.querySelector(`.api-row[data-api="${k}"]`);
                            if (!row) {
                                row = document.createElement('div');
                                row.className = 'api-row d-flex align-items-center';
                                row.dataset.api = k;
                                // Julian: Hier noch den API Namen hinzugefügt, unterscheidet zwischen API und CSV
                                row.innerHTML = `
                                    <div class="api-icon-wrap">
                                        <img src="${API_ICON_MAP[k] || '/static/images/icon.svg'}" class="api-icon" onerror="this.src='/static/images/icon.svg'" alt="${k}">
                                        <span class="status-dot offline"></span>
                                    </div>
                                    <div class="api-meta d-flex flex-column" style="margin-left:12px;">
                                        <div class="api-status-text">
                                            <strong class="api-name">${k}</strong> · 
                                            <span class="api-status">—</span>
                                        </div>
                                        <div class="api-lastpolled api-last">—</div>
                                    </div>
                                `;
                                apiRows.appendChild(row);
                            }
                            const dot = row.querySelector('.status-dot');
                            const last = row.querySelector('.api-last');
                            const statusNode = row.querySelector('.api-status');
                            if (a.status === 'ok') {
                                dot.classList.remove('offline', 'error'); dot.classList.add('ok');
                                statusNode.innerText = 'OK'; statusNode.classList.remove('error'); statusNode.classList.add('ok');
                            } else {
                                dot.classList.remove('offline', 'ok'); dot.classList.add('error');
                                statusNode.innerText = 'ERROR'; statusNode.classList.remove('ok'); statusNode.classList.add('error');
                            }
                            if (last) last.innerText = a.lastPolled ? formatRelativeTime(a.lastPolled) : '—';
                        });
                        // remove any rows for APIs that no longer exist in the response
                        Array.from(apiRows.querySelectorAll('.api-row')).forEach(r => {
                            const nm = r.dataset.api;
                            if (!body.apis[nm]) r.remove();
                        });
                    } else if (body && body.lastPolled) {
                        const txt = formatRelativeTime(body.lastPolled);
                        // update all rows existing in the menu
                        apiRows.querySelectorAll('.api-row').forEach(r => {
                            const last = r.querySelector('.api-last');
                            if (last) last.innerText = txt;
                        });
                    } else {
                        apiRows.querySelectorAll('.api-row').forEach(r => {
                            const last = r.querySelector('.api-last');
                            if (last) last.innerText = 'gerade eben';
                        });
                    }
                } else {
                    let body = null;
                    try { body = await res.json(); } catch (e) { body = null; }
                    console.debug('Status: ERROR');
                    // mark all available rows as error
                    apiRows.querySelectorAll('.api-row').forEach(r => {
                        const dot = r.querySelector('.status-dot');
                        const last = r.querySelector('.api-last');
                        const statusNode = r.querySelector('.api-status');
                        if (dot) { dot.classList.remove('ok'); dot.classList.add('error'); }
                        if (statusNode) { statusNode.innerText = 'FEHLER'; statusNode.classList.remove('ok'); statusNode.classList.add('error'); }
                        if (last) last.innerText = (body && body.lastPolled) ? formatRelativeTime(body.lastPolled) : '—';
                    });
                }
            } catch (err) {
                // API-Status auf "offline" setzen bei Fehler
                apiRows.querySelectorAll('.api-row').forEach(r => {
                    const dot = r.querySelector('.status-dot');
                    const last = r.querySelector('.api-last');
                    const statusNode = r.querySelector('.api-status');
                    if (dot) { dot.classList.remove('ok'); dot.classList.add('offline'); }
                    if (statusNode) { statusNode.innerText = '—'; statusNode.classList.remove('ok', 'error'); }
                    if (last) last.innerText = '—';
                });
            }
        }

        // Starte Status-Abfrage: initial + alle 15 Sekunden
        updateApiStatus();
        setInterval(updateApiStatus, 15000);
    </script>


</body>

</html>
